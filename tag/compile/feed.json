{
    "version": "https://jsonfeed.org/version/1",
    "title": "Пусть этот камень будет более крепким, чем человек • All posts by \"compile\" tag",
    "description": "有自己的博客很帅，但是我很懒，要命！！！",
    "home_page_url": "https://forcheetah.github.io",
    "items": [
        {
            "id": "https://forcheetah.github.io/2024/10/10/tvm01/",
            "url": "https://forcheetah.github.io/2024/10/10/tvm01/",
            "title": "【TVM】通过代码学习编译流程【1】必要知识",
            "date_published": "2024-10-10T12:12:43.910Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>本系列文章将从代码和流程图入手，详细介绍 TVM AI 编译器的编译流程。本文章为第一篇，取名为 “必要知识”，约等于 “大杂烩”。食之无味，弃之可惜。但基于我个人的主观喜好和偏见，这些知识值得在整个代码讲解之前声明。</p>\n<p>作为初学者，错误在所难免，还望不吝赐教。</p>\n<h1 id=\"工程结构\"><a class=\"anchor\" href=\"#工程结构\">#</a> 工程结构</h1>\n<p><a href=\"https://github.com/apache/tvm\">TVM</a> 主要由 C++ 语言和 Python 语言实现。</p>\n<ul>\n<li>\n<p>a.TVM C++ 后端核心代码   位于 /home/user/tvm/src<br>\nC++ 后端核心代码的功能是生成 <a href=\"http://libtvm.so\">libtvm.so</a> libtvm_runtime.so，分别是模型编译过程中的需要的 libtvm.so 库，和模型部署运行时需要的 libtvm_runtime.so 库。对应的头文件位于 /home/user/tvm/include.</p>\n<ul>\n<li>1. 其中 src/runtime 是模型部署相关 CPP 文件\n<ul>\n<li>src/runtime/graph_executor   最基本的图执行器</li>\n<li>src/runtime/module.cpp          运行时 Module 基类</li>\n<li>src/runtime/contrib                  BYOC 第三方设备运行及实现  包括 dnnl cblas cudnn ethosu 等等</li>\n<li>srd/runtime/cuda                    CUDA 运行时 Module</li>\n<li>还有其他设备的运行时 Module  如 opencl  hexagon   metal 等，以及一些接口文件</li>\n</ul>\n</li>\n<li>2.src/relay 是 TVM 高级中间表示 IR 的相关 CPP 文件</li>\n<li>3.src/relax TVM 正在发展的高级中间表示 IR，功能上等同于 Relay</li>\n<li>4.src/te      TVM 的 TE 表达式</li>\n<li>5.src/topi   算子的计算定义和后端调度</li>\n<li>6.src/tir      TVM 低级中介表示 IR，接近于硬件表示</li>\n<li>7.src/auto_shedule  TVM 自动优化调度相关</li>\n</ul>\n</li>\n<li>\n<p>b. TVM Python 前端代码      位于 /home/user/tvm/python<br>\nPython 前端代码为 C++ API 和执行编译的驱动代码，提供 Python 绑定。</p>\n</li>\n</ul>\n<p>表面上看 TVM 工程应当是 Python 前端调用 C++ 后端生成的 <a href=\"http://libtvm.so\">libtvm.so</a> libtvm_runtime.so ，实际上 TVM 支持 Python 和 C++ 的相互调用。例如一些算子的 compute 计算公式和 schedule 调度位于 Python 代码中，由 C++ 进行调用。</p>\n<p>在编译阶段，开发者编写 Python 代码，调用 TVM Python 前端，而 TVM 的 Python 前端又依赖于 C++ 后端生成的 libtvm.so libtvm_runtime.so 动态库。</p>\n<p>部署运行阶段即可以编写 Python 来执行，也可以直接编译 C++ 为可执行文件，参考<a href=\"https://github.com/ForCheetah/TvmCppDeploy\"> TVM C++ 部署</a></p>\n<h1 id=\"编译\"><a class=\"anchor\" href=\"#编译\">#</a> 编译</h1>\n<p>编译过程可以参考 TVM 英文文档和中文文档。文档中内容全面，这里只摘必要步骤，是最简单的部署安装方式。</p>\n<p>1. 编译 <a href=\"http://libtvm.so\">libtvm.so</a> libtvm_runtime.so</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> build  <span class=\"token comment\"># 下载工程后进入工程目录 创新文件夹</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">cp</span> cmake/config.cmake ./build</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\"># 将 cmake 配置文件拷贝到 build 目录，可以更改需要的额配置选项</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">cd</span> build</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>cmake <span class=\"token punctuation\">..</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">make</span> <span class=\"token parameter variable\">-j32</span></pre></td></tr></table></figure><p>2. 配置临时运行环境</p>\n<p>个人喜欢用临时环境运行项目，可以避免 .bashrc 文件中添加过多环境路径；特别是开发人员有多个 TVM 项目的时候，可以避免项目的混淆。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 指定 tvm 库路径</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/home/user/tvm/build:<span class=\"token environment constant\">$PATH</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 指定 tvm Python 路径</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">PYTHONPATH</span><span class=\"token operator\">=</span>/home/user/tvm/python:<span class=\"token variable\">$&#123;PYTHONPATH&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 运行</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>python3 ***.py</pre></td></tr></table></figure><h1 id=\"tvm-基类\"><a class=\"anchor\" href=\"#tvm-基类\">#</a> TVM 基类</h1>\n<p>大概从事工程项目开发的人员对 Object, ObjectPtr, ObjectRef 等写法相对熟悉，但是没有相关经验的算法研究人员，还是先认识一下 TVM 中的这三个基类。</p>\n<p>TVM 中大部分类都继承自三大基础类   Object, ObjectPtr, ObjectRef。想多了解一下的话，可以学习博客<a href=\"https://zhuanlan.zhihu.com/p/656435385\"> TVM: Object, ObjectPtr, ObjectRef (以 tir.sch 为例)</a> 。</p>\n<p>可能比较粗显的总结一下：TVM 中以 &quot;Node&quot; 结尾的类是 Object 的派生类，去掉 &quot;Node&quot; 的类是 ObjectRef 的派生类，Object 的派生类负责 &quot;做事&quot;，ObjectRef 的派生类方便程序员引用，ObjectPtr 是桥梁。但总之这三者是一个东西（刚学时我就被这搞晕了：(  ）。</p>\n<p>举例说明如何使用 TVM 的三大基础类构造对象:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Anode</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> tvm<span class=\"token double-colon punctuation\">::</span>runtime<span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Object</span></span><span class=\"token punctuation\">&#123;</span>   </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token function\">Anode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token operator\">~</span><span class=\"token function\">Anode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">return</span> <span class=\"token string\">\"instance\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> tvm<span class=\"token double-colon punctuation\">::</span>runtime<span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">ObjectRef</span></span><span class=\"token punctuation\">&#123;</span>       </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> tvm<span class=\"token double-colon punctuation\">::</span>runtime<span class=\"token double-colon punctuation\">::</span>ObjectRef<span class=\"token punctuation\">,</span> Anode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   tvm<span class=\"token double-colon punctuation\">::</span>runtime<span class=\"token double-colon punctuation\">::</span>ObjectPtr<span class=\"token operator\">&lt;</span>Anode<span class=\"token operator\">></span> n <span class=\"token operator\">=</span> tvm<span class=\"token double-colon punctuation\">::</span>runtime<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">make_object</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Anode<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 桥梁 Ptr = make_object (本体 node)    </span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   A <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 指针</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>   ref<span class=\"token operator\">-></span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// Anode 指针，可以引用 a ()</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>   <span class=\"token comment\">//ref.get ()->a (); // 基类 Object 指针，error Object has no member a ()</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img loading=\"lazy\" data-src=\"1728562036320.jpg\" alt=\"Object 应用例子\"></p>\n<p>可以再看一下 TVM 工程中的例子，这段代码创建了本体 <code>CallNode</code> ，通过 make_object 生成桥梁 <code>ObjectPtr&lt;CallNode&gt;</code> ，最后赋值给指针 <code>Call</code>  的 <code>data_</code> 字段。</p>\n<h1 id=\"python和c相互调用\"><a class=\"anchor\" href=\"#python和c相互调用\">#</a> Python 和 C++ 相互调用</h1>\n<p>TVM 实现了 FFI (Foreign Function Interface) 机制，目标是使得任意语言下定义的函数都可以被任意其他语言调用。</p>\n<p>宏 TVM_REGISTER_GLOBAL</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/*!</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * \\brief Register a function globally.</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> * \\code</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> *   TVM_REGISTER_GLOBAL(\"MyPrint\")</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> *   .set_body([](TVMArgs args, TVMRetValue* rv) &#123;</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> *   &#125;);</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * \\endcode</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> */</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">TVM_REGISTER_GLOBAL</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>OpName<span class=\"token punctuation\">)</span> </span><span class=\"token punctuation\">\\</span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token expression\"><span class=\"token function\">TVM_STR_CONCAT</span><span class=\"token punctuation\">(</span>TVM_FUNC_REG_VAR_DEF<span class=\"token punctuation\">,</span> __COUNTER__<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token double-colon punctuation\">::</span>tvm<span class=\"token double-colon punctuation\">::</span>runtime<span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Registry</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">Register</span><span class=\"token punctuation\">(</span>OpName<span class=\"token punctuation\">)</span></span></pre></td></tr></table></figure><p>在 C++ 后端同过 “TVM_REGISTER_GLOBAL” 这个宏将函数注册为全局函数，该全局函数的类型为 PackedFunc。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">TVM_REGISTER_GLOBAL</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tvm.graph_executor_factory.create\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 注册为全局函数 PackedFunc</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">set_body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>TVMArgs args<span class=\"token punctuation\">,</span> TVMRetValue<span class=\"token operator\">*</span> rv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>      </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token operator\">*</span>rv <span class=\"token operator\">=</span> <span class=\"token function\">Module</span><span class=\"token punctuation\">(</span>exec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在 Python 前端可以通过 get_global_func () 函数来获取全局函数 PackedFunc 并执行</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>fcreate <span class=\"token operator\">=</span> get_global_func<span class=\"token punctuation\">(</span><span class=\"token string\">\"tvm.graph_executor_facttory.create\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>self<span class=\"token punctuation\">.</span>module <span class=\"token operator\">=</span> fcreate<span class=\"token punctuation\">(</span>graph_json_str<span class=\"token punctuation\">,</span> libmod<span class=\"token punctuation\">,</span> libmod_name<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>在 C++ 端也可以通过名字获取 全局函数 PackedFunc</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>PackedFunc pf <span class=\"token operator\">=</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">GetFunction</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>python 端有大量如下类似代码，将有相同后缀的 PackedFunc 注册到 Python 端</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token triple-quoted-string string\">\"\"\"FFI APIs for tvm.ir\"\"\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> tvm<span class=\"token punctuation\">.</span>_ffi</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>tvm<span class=\"token punctuation\">.</span>_ffi<span class=\"token punctuation\">.</span>_init_api<span class=\"token punctuation\">(</span><span class=\"token string\">\"ir\"</span><span class=\"token punctuation\">,</span> __name__<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>Python 端获取并执行 PackedFunc</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>_ffi_api<span class=\"token punctuation\">.</span>Module_UpdateGlobalInfo<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> global_info<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h1 id=\"后记\"><a class=\"anchor\" href=\"#后记\">#</a> 后记</h1>\n<p>本博客目前以及可预期的将来都不会支持评论功能。各位大侠如若有指教和问题，可以在我的 <a href=\"https://github.com/ForCheetah/ForCheetah.github.io\">github 项目</a> 或随便一个项目下提出 issue，或者<a href=\"https://www.zhihu.com/people/guai-dao-ji-de-3-50\">知乎</a> 私信，并指明哪一篇博客，我看到一定及时回复，感激不尽！global_info)</p>\n",
            "tags": [
                "tvm",
                "compile"
            ]
        }
    ]
}